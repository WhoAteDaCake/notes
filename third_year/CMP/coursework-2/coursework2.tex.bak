\documentclass{article}

\usepackage[%
    left=0.5in,%
    right=0.5in,%
    top=0.5in,%
    bottom=0.5in,%
]{geometry}%
\usepackage{minitoc}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
    \hypersetup{ colorlinks = true, linkcolor = blue }
\usepackage{blindtext}
\definecolor{lightgray}{gray}{0.9}
\graphicspath{ {./} }

\newcommand{\inlinecode}[2]{\colorbox{lightgray}{\lstinline
[language=#1]$#2$}}
\newcommand{\worddef}[1]{\hyperref[sec:reference]{\textit{#1}}}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}

\begin{document}

\tableofcontents

\newpage

\section{Task 1}

\subsection{Repeat until}

\begin{center}
  \includegraphics[scale=0.1]{repeat_type.jpg}
\end{center}


\subsection{Character literal}

\begin{center}
  \includegraphics[scale=0.1]{char_type.jpg}
\end{center}


\subsection{If-else extended}

\begin{center}
  \includegraphics[scale=0.1]{if-else_type.jpg}
\end{center}


\subsection{Conditional}

\begin{center}
  \includegraphics[scale=0.1]{conditional_type.jpg}
\end{center}


\section{Task 2}

\subsection{Repeat until}

\subsubsection{MTIR}

\begin{flushleft}
Update the MiniTriangle Internal Representation inside, so we can stored typed version
\end{flushleft}
\begin{code}
    -- | Repeat until
    | CmdRepeat {
          crCond    :: Expression,      -- ^ Loop-condition
          crBody    :: Command,         -- ^ Loop-body
          cmdSrcPos :: SrcPos
      }
\end{code}

\subsubsection{TypeChecker}
\begin{flushleft}
Add a pattern match for type checking AST \texttt{CmdRepeat} data type
\end{flushleft}
\begin{code}
-- T-REPEAT
chkCmd env (A.CmdRepeat {A.crCond = e, A.crBody = c, A.cmdSrcPos = sp}) = do
    e' <- chkTpExp env e Boolean                        -- env |- e : Boolean
    c' <- chkCmd env c                                  -- env |- c
    return (CmdRepeat {crCond = e', crBody = c', cmdSrcPos = sp})
\end{code}

\subsubsection{PPMTIR}
\begin{flushleft}
Now need a way to print the typed repeat command. We do this by adding a \texttt{CmdRepeat} pattern match to \texttt{ppCommand}
\end{flushleft}
\begin{code}
ppCommand n (CmdRepeat {crCond = e, crBody = c, cmdSrcPos = sp}) =
    indent n . showString "CmdRepeat" . spc . ppSrcPos sp . nl
    . ppCommand (n+1) c
    . ppExpression (n+1) e
\end{code}

\subsection{Character literal}

\subsubsection{Type}

\begin{flushleft}
Firstly we add \texttt{Character} to Type data type
\end{flushleft}
\begin{code}
| Character           -- ^ The Character type
\end{code}
\begin{flushleft}
Next inside \texttt{instance Eq Type where} we add an equality operator pattern for it.
\end{flushleft}
\begin{code}
Character  == Character  = True
\end{code}
\begin{flushleft}
Finally, we add Character pattern match to \texttt{instance Show Type where}
\end{flushleft}
\begin{code}
showsPrec _ Character  = showString "Character"
\end{code}

\subsubsection{TypeChecker}

\begin{flushleft}
We add a \texttt{ExpLitChar} pattern match to \texttt{infTpExp}. The only thing we do here is convert the character value to \texttt{MTChar} and transform $AST \rightarrow MTIR$
\end{flushleft}
\begin{code}
-- T-CHAR
infTpExp env e@(A.ExpLitChr {A.elcVal = c, A.expSrcPos = sp}) = do
    c' <- toMTChr c sp
    return (Character,                          -- env |- n : Character
            ExpLitChr {elcVal = c', expType = Character, expSrcPos = sp})
\end{code}

\subsection{If-else extended}

\subsubsection{MTIR}
\begin{flushleft}
Firstly, we update the internal representation to allow multiple \textit{elsif} and optional \textit{else} branches. Do this by modifying \texttt{CmdIf} inside \texttt{Command} data type.
\end{flushleft}
\begin{code}
-- | Conditional command
| CmdIf {
      ciCondThens :: [(Expression,
                       Command)],   -- ^ Conditional branches
      ciMbElse    :: Maybe Command, -- ^ Optional else-branch
      cmdSrcPos   :: SrcPos
  }
\end{code}

\subsubsection{PPMTIR}
\begin{flushleft}
Now we need to update the pretty print function, so the new syntax can be seen
\end{flushleft}
\begin{code}
ppCommand n (CmdIf {ciCondThens = ecs, ciMbElse = mc, cmdSrcPos = sp}) =
    indent n . showString "CmdIf" . spc . ppSrcPos sp . nl
    . ppSeq (n+1) (\n (e,c) -> ppExpression n e . ppCommand n c) ecs
    . ppOpt (n+1) ppCommand mc
\end{code}

\subsubsection{TypeChecker}
\begin{flushleft}
Next we have to 
\end{flushleft}

\end{document}
