\documentclass{article}

\usepackage[%
    left=0.5in,%
    right=0.5in,%
    top=0.5in,%
    bottom=0.5in,%
]{geometry}%
\usepackage{minitoc}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
    \hypersetup{ colorlinks = true, linkcolor = blue }
\usepackage{blindtext}
\definecolor{lightgray}{gray}{0.9}
\graphicspath{ {./} }

\newcommand{\inlinecode}[2]{\colorbox{lightgray}{\lstinline
[language=#1]$#2$}}
\newcommand{\worddef}[1]{\hyperref[sec:reference]{\textit{#1}}}

\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}

\begin{document}

\tableofcontents

\newpage

\section{Task 1}

\subsection{Extending token}
\begin{flushleft}
First step is to extend the \texttt{Token} data type found in \textit{Token.hs} file.
\end{flushleft}
\begin{code}
| Repeat    -- ^ \"repeat\"
| Until     -- ^ \"until\"
\end{code}

\subsection{Adding keywords to the scanner}
\begin{flushleft}
Second step is to have new keywords be picked up by our scanner, to do this we have to update \texttt{mkIdOrKwd} function in \textit{Scanner.hs} file.
\end{flushleft}
\begin{code}
mkIdOrKwd "repeat" = Repeat
mkIdOrKwd "until" = Until
\end{code}

\subsection{Adding new command to AST}
\begin{flushleft}
We now have defined the token as well as we are able to recognize it using the scanner. The next step is to be able to represent it in out abstract syntax tree. To do so, we update \texttt{Command} data type inside \texttt{AST.hs}.
\end{flushleft}
\begin{code}
-- repeat until
| CmdRepeat {
      crCmd     :: Command,         -- ^ Action
      crCond    :: Expression,      -- ^ Condition
      cmdSrcPos :: SrcPos 
  }
\end{code}

\subsection{Keyword parser recognision}
\begin{flushleft}
The next step is to update our parser to support this new syntax (all modification will be done to \texttt{Parser.y} file). First we modify the \texttt{token} to contain our new defined syntax
\end{flushleft}
\begin{code}
REPEAT      { (Repeat, $$) }
UNTIL       { (Until, $$) }
\end{code}
\begin{flushleft}
Next step is to add our command definition to the \texttt{command} function:
\end{flushleft}
\begin{code}
| REPEAT command UNTIL expression
    { CmdRepeat {crCmd = $2, crCond = $4, cmdSrcPos = $1} }
\end{code}
\begin{flushleft}
At this point our command will be picked up by the parser and the relative AST will be generated.
\end{flushleft}

\subsection{Pretty print}
\begin{flushleft}
To allow debugging of the new syntax by printing, we have to add our command defined in \textit{AST.hs} to \textit{PPAST.hs} file. We add one more pattern match to \texttt{ppCommand}
\end{flushleft}
\begin{code}
ppCommand n (CmdRepeat {crCmd = cmd, crCond = cond, cmdSrcPos = sp}) =
    indent n . showString "CmdRepeat" . spc . ppSrcPos sp . nl
    . ppCommand (n+1) cmd 
    . ppExpression (n+1) cond
\end{code}

\pagebreak
\section*{Reference section} \label{sec:reference}
\begin{description}
	\item[placeholder] \hfill \\
\end{description}
\end{document}
