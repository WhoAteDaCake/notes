\documentclass{article}

\usepackage[%
    left=0.5in,%
    right=0.5in,%
    top=0.5in,%
    bottom=0.5in,%
]{geometry}%
\usepackage{minitoc}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
    \hypersetup{ colorlinks = true, linkcolor = blue }
\usepackage{blindtext}
\definecolor{lightgray}{gray}{0.9}
\graphicspath{ {./} }

\newcommand{\inlinecode}[2]{\colorbox{lightgray}{\lstinline
[language=#1]$#2$}}
\newcommand{\worddef}[1]{\hyperref[sec:reference]{\textit{#1}}}

\begin{document}

\tableofcontents

\newpage

\section{Buffer Overflows}
\begin{itemize}
  \item When a program is executed, contiguous blocks of memory can be allocated to store arrays (buffers) 
  \item If data is written into a buffer that exceeds its size, an overflow occurs 
  \item The data will overwrite the memory beyond the buffer – Bad!
\end{itemize}

\subsection{Stack Smashing}
\begin{itemize}
  \item In C and C++, low level functions like strcpy perform no bounds checking at all 
  \item If str is long, we can write into other memory
  \item By crafting the string str, we can overwrite the buffer and the return address with custom exploit code!
  \item E.g. unended string, could make it so we read past it, meaning we copy values we shouldn't access to the buffer
  \item E.g. if buffer is not large enough to fit the string, we might override return address and start execution from another point in code
\end{itemize}

\subsection{Protection: Canaries}
\begin{itemize}
  \item Stack canaries modify the prologue and epilogue of all functions to check a value in front of the return address is unchanged:
  \item If you can work out the canary value, there is no issue. You could also corrupt the Structured Exception Handler (SEH)
\end{itemize}

\subsection{Data Execution Prevention (NX)}
\begin{itemize}
  \item Modern operating systems (where possible) will mark the stack as non-executable. 
  \item NX on AMD, XD on Intel, XN on arm 
  \item An NX stack means that adding in our exploit code won’t work 
  \item We can circumvent this using a return-to-libc attack
\end{itemize}

\subsection{Further Protection}
\begin{itemize}
  \item To defeat ret2libc various 0x0 null bytes are inserted into standard library addresses 
  \item Developers also restrict access to obvious system calls 
  \item Address Space Layout Randomisation (ASLR) moves the address of library and programs around. Every time the program is ran, the stack is moved in address space. 
  \item They don’t have to move too much before your hand-crafted ret addresses will break
\end{itemize}

\section{Return-Oriented Programming}
\begin{flushleft}
Utilizing parts of program in order to generate a sequence of events that would align a stack and push shell scripts on to it.
\end{flushleft}

\section{Race conditions}
\begin{flushleft}
It's a time of check and time of use issue. If we validate something and before we execute it, a program manages to perform a malicious action, there is no way we could catch that.
\end{flushleft}

\section{Heartbleed}
\begin{itemize}
  \item Heartbleed is a bug in OpenSSL
  \item Problem with a buffer overread
  \item When a message was sent with different request.size and payload.size, server memory would be copied.
\end{itemize}


\pagebreak
\section*{Reference section} \label{sec:reference}
\begin{description}
	\item[placeholder] \hfill \\
\end{description}
\end{document}
